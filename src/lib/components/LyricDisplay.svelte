<script lang="ts">
	import type { LyricAnalysis } from '$lib/types/lyric.js';
	import WordUnit from './WordUnit.svelte';
	import RecordingMenu from './RecordingMenu.svelte';
	import { onMount } from 'svelte';

	export let analysis: LyricAnalysis;
	export let selectedVoice: string = '';
	export let lyricId: string = ''; // 新增歌词ID

	// 全局voice选择
	let voices: SpeechSynthesisVoice[] = [];

	function getVoicesForLang(lang: string) {
		if (typeof window !== 'undefined') {
			return window.speechSynthesis.getVoices().filter(v => v.lang.startsWith(lang));
		}
		return [];
	}

	function handleVoiceInit() {
		voices = getVoicesForLang(analysis.sourceLanguage);
		if (!selectedVoice && voices.length > 0) {
			selectedVoice = voices[0].voiceURI;
		}
	}

	onMount(() => {
		if (typeof window !== 'undefined' && window.speechSynthesis) {
			// 先尝试同步获取
			handleVoiceInit();

			// 监听 voiceschanged 事件，异步加载
			window.speechSynthesis.onvoiceschanged = () => {
				handleVoiceInit();
			};
		}
	});

	function speakLine(line: string, lang: string) {
		if (!window.speechSynthesis) return;
		const utter = new window.SpeechSynthesisUtterance(line);
		utter.lang = mapLang(lang);
		utter.rate = 0.5;
		const allVoices = window.speechSynthesis.getVoices();
		const match = allVoices.find(v => v.voiceURI === selectedVoice) || allVoices.find(v => v.lang.startsWith(utter.lang));
		if (match) utter.voice = match;
		window.speechSynthesis.speak(utter);
	}

	function mapLang(code: string): string {
		if (code === 'zh') return 'zh-CN';
		if (code === 'yue') return 'zh-HK'; // 粤语
		if (code === 'en') return 'en-US';
		if (code === 'fr') return 'fr-FR';
		if (code === 'es') return 'es-ES';
		if (code === 'de') return 'de-DE';
		if (code === 'ja') return 'ja-JP';
		if (code === 'ko') return 'ko-KR';
		if (code === 'it') return 'it-IT';
		if (code === 'pt') return 'pt-PT';
		if (code === 'ru') return 'ru-RU';
		return code;
	}

	function getSortedVoices() {
		if (!voices || !selectedVoice) return voices;
		const selected = voices.find(v => v.voiceURI === selectedVoice);
		const rest = voices.filter(v => v.voiceURI !== selectedVoice);
		console.log('【voice debug】getSortedVoices', selected, rest);
		return selected ? [selected, ...rest] : voices;
	}


	// 长按菜单相关状态
	let longPressTimer: ReturnType<typeof setTimeout> | null = null;
	let showLineRecordingMenu = false;
	let menuPosition = { x: 0, y: 0 };
	let currentLineNumber: number | null = null;
	const LONG_PRESS_DELAY = 500; // 长按500ms触发菜单

	// 长按开始
	function handleLineMouseDown(event: MouseEvent, lineNumber: number) {
		// 阻止默认行为，防止触发点击事件
		event.preventDefault();
		longPressTimer = setTimeout(() => {
			showLineRecordingMenu = true;
			menuPosition = { x: event.clientX, y: event.clientY };
			currentLineNumber = lineNumber;
		}, LONG_PRESS_DELAY);
	}

	// 长按结束
	function handleLineMouseUp(event: MouseEvent) {
		if (longPressTimer) {
			clearTimeout(longPressTimer);
			longPressTimer = null;
		}
		// 如果菜单已显示，阻止默认行为
		if (showLineRecordingMenu) {
			event.preventDefault();
		}
	}

	// 长按取消
	function handleLineMouseLeave() {
		if (longPressTimer) {
			clearTimeout(longPressTimer);
			longPressTimer = null;
		}
	}

	// 右键菜单
	function handleLineContextMenu(event: MouseEvent, lineNumber: number) {
		event.preventDefault(); // 阻止浏览器默认右键菜单
		showLineRecordingMenu = true;
		menuPosition = { x: event.clientX, y: event.clientY };
		currentLineNumber = lineNumber;
	}

	// 触摸开始
	function handleLineTouchStart(event: TouchEvent, lineNumber: number) {
		event.preventDefault(); // 阻止默认行为
		const touch = event.touches[0];
		longPressTimer = setTimeout(() => {
			showLineRecordingMenu = true;
			menuPosition = { x: touch.clientX, y: touch.clientY };
			currentLineNumber = lineNumber;
		}, LONG_PRESS_DELAY);
	}

	// 触摸结束
	function handleLineTouchEnd(event: TouchEvent) {
		if (longPressTimer) {
			clearTimeout(longPressTimer);
			longPressTimer = null;
		}
		// 如果菜单已显示，阻止默认行为
		if (showLineRecordingMenu) {
			event.preventDefault();
		}
	}

	// 触摸移动
	function handleLineTouchMove(event: TouchEvent) {
		if (longPressTimer) {
			clearTimeout(longPressTimer);
			longPressTimer = null;
		}
	}

	// 关闭录音菜单
	function closeLineRecordingMenu() {
		showLineRecordingMenu = false;
		currentLineNumber = null;
	}

	// 键盘事件处理
	function handleLineKeyDown(event: KeyboardEvent, lineNumber: number) {
		if (event.key === 'Enter' || event.key === ' ') {
			event.preventDefault();
			showLineRecordingMenu = true;
			const target = event.target as HTMLElement;
			const rect = target.getBoundingClientRect();
			menuPosition = { x: rect.left, y: rect.bottom };
			currentLineNumber = lineNumber;
		}
	}
</script>

<!-- 全局voice选择 -->
<div class="flex items-center gap-2 mb-4">
	<label for="voice-select" class="text-sm text-gray-600">发音Voice：</label>
	{#if voices.length > 0}
		<select
			id="voice-select"
			bind:value={selectedVoice}
			class="text-xs border rounded px-1 py-0.5"
		>
			{#each getSortedVoices() as v}
				<option value={v.voiceURI}>{v.name} ({v.lang})</option>
			{/each}
		</select>
	{:else}
		<span class="text-xs text-gray-400">无可用发音</span>
	{/if}
</div>

<div class="lyric-display space-y-6">
	<!-- 整体总结 -->
	{#if analysis.summary}
		<div class="summary-section bg-blue-50 border-l-4 border-blue-400 p-4 rounded-r-lg mb-6">
			<h3 class="text-lg font-semibold text-blue-800 mb-2">🎵 歌曲总结</h3>
			<p class="text-blue-700 leading-relaxed">{analysis.summary}</p>
		</div>
	{/if}

	<!-- 逐行分析 -->
	<div class="line-analysis-section">
		<h3 class="text-lg font-semibold text-gray-800 mb-4">🔍 逐字分析</h3>
		{#each analysis.lines as line}
			<div class="lyric-line-box mb-6 p-4 border border-gray-200 rounded-lg bg-white">
				<div class="flex justify-between items-center mb-2">
					<div class="flex items-center gap-4 w-full">
						<span 
							class="text-xs text-gray-500 font-mono whitespace-nowrap cursor-pointer hover:text-gray-700"
							on:mousedown={(e) => handleLineMouseDown(e, line.lineNumber)}
							on:mouseup={handleLineMouseUp}
							on:mouseleave={handleLineMouseLeave}
							on:contextmenu={(e) => handleLineContextMenu(e, line.lineNumber)}
							on:touchstart={(e) => handleLineTouchStart(e, line.lineNumber)}
							on:touchend={handleLineTouchEnd}
							on:touchmove={handleLineTouchMove}
							on:keydown={(e) => handleLineKeyDown(e, line.lineNumber)}
							title="长按录制整句发音，右键录音菜单"
							role="button"
							tabindex="0"
						>
							第 {line.lineNumber} 行
						</span>
						{#if line.lineTranslation}
							<span 
								class="line-translation-inhead text-base text-gray-900 font-semibold truncate cursor-pointer hover:text-gray-700" 
								style="max-width: 70vw;"
								on:mousedown={(e) => handleLineMouseDown(e, line.lineNumber)}
								on:mouseup={handleLineMouseUp}
								on:mouseleave={handleLineMouseLeave}
								on:contextmenu={(e) => handleLineContextMenu(e, line.lineNumber)}
								on:touchstart={(e) => handleLineTouchStart(e, line.lineNumber)}
								on:touchend={handleLineTouchEnd}
								on:touchmove={handleLineTouchMove}
								on:keydown={(e) => handleLineKeyDown(e, line.lineNumber)}
								title="长按录制整句发音，右键录音菜单"
								role="button"
								tabindex="0"
							>
								{line.lineTranslation}
							</span>
						{/if}
					</div>
					<button
						type="button"
						class="text-gray-400 hover:text-primary-600 text-sm px-2 py-1 rounded focus:outline-none ml-2"
						on:click={() => speakLine(line.words.map(w => w.word).join(' '), analysis.sourceLanguage)}
						title="朗读整句"
					>
						🔊 
					</button>
				</div>
				<!-- 逐字分析 -->
				<div class="flex flex-wrap gap-2 items-start">
					{#each line.words as word}
						<WordUnit {word} sourceLanguage={analysis.sourceLanguage} targetLanguage={analysis.targetLanguage} selectedVoice={selectedVoice} lyricId={lyricId} />
					{/each}
				</div>
			</div>
		{/each}
	</div>
</div>

<!-- 整句录音菜单 -->
{#if showLineRecordingMenu && currentLineNumber !== null}
	<RecordingMenu 
		{lyricId}
		lineNumber={currentLineNumber}
		isVisible={showLineRecordingMenu}
		position={menuPosition}
		on:close={closeLineRecordingMenu}
	/>
{/if}

<style>
	.lyric-display {
		font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
		line-height: 1.6;
	}

	.lyric-line-box {
		margin-bottom: 1.5rem;
		background: #fff;
	}

	.summary-section {
		box-shadow: 0 1px 3px rgba(0, 0, 0, 0.07);
	}

	.line-translation-inhead {
		margin-left: 1.5rem;
		font-size: 1.08em;
		font-weight: 600;
		color: #222;
		white-space: pre-line;
	}
</style> 